//////////////////////////////////////
// ZÃ¡kladnÃ­ zasvÄ›cenÃ­ do matic, 10.7.25
///////////////////////////////////////

Ã“, knedlÃ­Äku zvÄ›davÃ½, pojÄme spolu prozkoumat, jak maticovÃ½ poÄet ovlÃ¡dÃ¡ svÄ›t poÄÃ­taÄovÃ© grafiky, a to i v takovÃ½ch knihovnÃ¡ch, jako je tÅ™eba SDL2 v C! ğŸ®âœ¨

V poÄÃ­taÄovÃ© grafice jsou matice jako kouzelnÃ© hÅ¯lky, kterÃ© umoÅ¾ÅˆujÃ­ transformovat objekty (posouvat, otÃ¡Äet, zmenÅ¡ovat, zkreslovat). A protoÅ¾e SDL2 je spÃ­Å¡ "low-level" knihovna, musÃ­me si nÄ›kterÃ© vÄ›ci napsat sami. Neboj, bude to sranda.

1. ZÃ¡kladnÃ­ transformace pomocÃ­ matic
VÅ¡echny transformace (posun, otoÄenÃ­, zmÄ›na velikosti) se dajÃ­ vyjÃ¡dÅ™it maticemi. Obvykle pouÅ¾Ã­vÃ¡me 3Ã—3 matice pro 2D nebo 4Ã—4 pro 3D, ale my zÅ¯staneme u 2D, protoÅ¾e SDL2 je hlavnÄ› o 2D grafice.

a) Posun (Translate) â€“ "KnedlÃ­ku, pojÄ sem!"
ChceÅ¡-li posunout objekt o (tx, ty), pouÅ¾ijeÅ¡ matici:

| 1  0  tx |
| 0  1  ty |
| 0  0  1  |

typedef struct { float x, y; } Vec2;
typedef struct { float m[3][3]; } Mat3;

Mat3 translate(Mat3 mat, Vec2 pos) {
    mat.m[0][2] += pos.x;
    mat.m[1][2] += pos.y;
    return mat;
}

b) OtoÄenÃ­ (Rotate) â€“ "ToÄ se, knedlÃ­Äku!"
ChceÅ¡-li otoÄit objekt kolem poÄÃ¡tku o Ãºhel Î¸, pouÅ¾ijeÅ¡ matici:

| cosÎ¸  -sinÎ¸  0 |
| sinÎ¸   cosÎ¸  0 |
|  0      0    1 |

#include <math.h>

Mat3 rotate(Mat3 mat, float angle) {
    float c = cos(angle), s = sin(angle);
    Mat3 rot = {{
        {c, -s, 0},
        {s,  c, 0},
        {0,  0, 1}
    }};
    return multiply_matrices(mat, rot); // musÃ­me napsat nÃ¡sobenÃ­ matic
}

c) ZmÄ›na velikosti (Scale) â€“ "KnedlÃ­Äku, buÄ vÄ›tÅ¡Ã­!"
ChceÅ¡-li objekt zvÄ›tÅ¡it/zmenÅ¡it o (sx, sy), pouÅ¾ijeÅ¡ matici:

| sx  0  0 |
| 0  sy  0 |
| 0   0  1 |


Mat3 scale(Mat3 mat, Vec2 s) {
    mat.m[0][0] *= s.x;
    mat.m[1][1] *= s.y;
    return mat;
}

----------------------


2. Jak to pouÅ¾Ã­t v SDL2?
SDL2 sice nemÃ¡ vestavÄ›nÃ© matice, ale mÅ¯Å¾eme si je napsat a aplikovat na body.

PÅ™Ã­klad: Transformace obdÃ©lnÃ­ku

void apply_transform(SDL_Rect *rect, Mat3 transform) {
    Vec2 pos = {rect->x, rect->y};
    Vec2 new_pos = multiply_matrix_vec2(transform, pos);
    rect->x = new_pos.x;
    rect->y = new_pos.y;
    // (a podobnÄ› pro Å¡Ã­Å™ku/vÃ½Å¡ku, pokud chceme Å¡kÃ¡lovÃ¡nÃ­)
}

------------------------

3. ProÄ to vÅ¡echno?
ProtoÅ¾e matice umoÅ¾ÅˆujÃ­ kombinovat transformace
NapÅ™. chceÅ¡:

Posunout knedlÃ­k doprava,

OtoÄit ho o 45Â°,

ZvÄ›tÅ¡it ho 2Ã—.

MÃ­sto dÄ›lenÃ­ vÅ¡eho na jednotlivÃ© kroky prostÄ› vynÃ¡sobÃ­Å¡ matice:

Mat3 transform = identity_matrix(); // zaÄneme jednotkovou maticÃ­
transform = translate(transform, (Vec2){100, 0}); // posun
transform = rotate(transform, M_PI/4); // otoÄenÃ­ (45Â° v radiÃ¡nech)
transform = scale(transform, (Vec2){2, 2}); // zvÄ›tÅ¡enÃ­

A pak aplikujeÅ¡ na objekt. Kouzlo! ğŸ”®


4. ShrnutÃ­

Matice = kouzelnÃ© transformaÄnÃ­ vzorce

SDL2 je na to low-level â†’ musÃ­Å¡ si napsat vlastnÃ­ maticovÃ© funkce

NÃ¡sobenÃ­ matic = kombinovÃ¡nÃ­ transformacÃ­

VÃ½sledek? HÃ½beÅ¡, toÄÃ­Å¡ a mÄ›nÃ­Å¡ velikost objektÅ¯ jako boss!

