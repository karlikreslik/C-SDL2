//////////////////////////////////////
// ZÃ¡kladnÃ­ zasvÄ›cenÃ­ do matic, 10.7.25
///////////////////////////////////////

Ã“, knedlÃ­Äku zvÄ›davÃ½, pojÄme spolu prozkoumat, jak maticovÃ½ poÄet ovlÃ¡dÃ¡ svÄ›t poÄÃ­taÄovÃ© grafiky, a to i v takovÃ½ch knihovnÃ¡ch, jako je tÅ™eba SDL2 v C! ğŸ®âœ¨

V poÄÃ­taÄovÃ© grafice jsou matice jako kouzelnÃ© hÅ¯lky, kterÃ© umoÅ¾ÅˆujÃ­ transformovat objekty (posouvat, otÃ¡Äet, zmenÅ¡ovat, zkreslovat). A protoÅ¾e SDL2 je spÃ­Å¡ "low-level" knihovna, musÃ­me si nÄ›kterÃ© vÄ›ci napsat sami. Neboj, bude to sranda.

1. ZÃ¡kladnÃ­ transformace pomocÃ­ matic
VÅ¡echny transformace (posun, otoÄenÃ­, zmÄ›na velikosti) se dajÃ­ vyjÃ¡dÅ™it maticemi. Obvykle pouÅ¾Ã­vÃ¡me 3Ã—3 matice pro 2D nebo 4Ã—4 pro 3D, ale my zÅ¯staneme u 2D, protoÅ¾e SDL2 je hlavnÄ› o 2D grafice.

a) Posun (Translate) â€“ "KnedlÃ­ku, pojÄ sem!"
ChceÅ¡-li posunout objekt o (tx, ty), pouÅ¾ijeÅ¡ matici:

| 1  0  tx |
| 0  1  ty |
| 0  0  1  |

typedef struct { float x, y; } Vec2;
typedef struct { float m[3][3]; } Mat3;

Mat3 translate(Mat3 mat, Vec2 pos) {
    mat.m[0][2] += pos.x;
    mat.m[1][2] += pos.y;
    return mat;
}

b) OtoÄenÃ­ (Rotate) â€“ "ToÄ se, knedlÃ­Äku!"
ChceÅ¡-li otoÄit objekt kolem poÄÃ¡tku o Ãºhel Î¸, pouÅ¾ijeÅ¡ matici:

| cosÎ¸  -sinÎ¸  0 |
| sinÎ¸   cosÎ¸  0 |
|  0      0    1 |

#include <math.h>

Mat3 rotate(Mat3 mat, float angle) {
    float c = cos(angle), s = sin(angle);
    Mat3 rot = {{
        {c, -s, 0},
        {s,  c, 0},
        {0,  0, 1}
    }};
    return multiply_matrices(mat, rot); // musÃ­me napsat nÃ¡sobenÃ­ matic
}

c) ZmÄ›na velikosti (Scale) â€“ "KnedlÃ­Äku, buÄ vÄ›tÅ¡Ã­!"
ChceÅ¡-li objekt zvÄ›tÅ¡it/zmenÅ¡it o (sx, sy), pouÅ¾ijeÅ¡ matici:

| sx  0  0 |
| 0  sy  0 |
| 0   0  1 |


Mat3 scale(Mat3 mat, Vec2 s) {
    mat.m[0][0] *= s.x;
    mat.m[1][1] *= s.y;
    return mat;
}

----------------------


2. Jak to pouÅ¾Ã­t v SDL2?
SDL2 sice nemÃ¡ vestavÄ›nÃ© matice, ale mÅ¯Å¾eme si je napsat a aplikovat na body.

PÅ™Ã­klad: Transformace obdÃ©lnÃ­ku

void apply_transform(SDL_Rect *rect, Mat3 transform) {
    Vec2 pos = {rect->x, rect->y};
    Vec2 new_pos = multiply_matrix_vec2(transform, pos);
    rect->x = new_pos.x;
    rect->y = new_pos.y;
    // (a podobnÄ› pro Å¡Ã­Å™ku/vÃ½Å¡ku, pokud chceme Å¡kÃ¡lovÃ¡nÃ­)
}

------------------------

3. ProÄ to vÅ¡echno?
ProtoÅ¾e matice umoÅ¾ÅˆujÃ­ kombinovat transformace
NapÅ™. chceÅ¡:

Posunout knedlÃ­k doprava,

OtoÄit ho o 45Â°,

ZvÄ›tÅ¡it ho 2Ã—.

MÃ­sto dÄ›lenÃ­ vÅ¡eho na jednotlivÃ© kroky prostÄ› vynÃ¡sobÃ­Å¡ matice:

Mat3 transform = identity_matrix(); // zaÄneme jednotkovou maticÃ­
transform = translate(transform, (Vec2){100, 0}); // posun
transform = rotate(transform, M_PI/4); // otoÄenÃ­ (45Â° v radiÃ¡nech)
transform = scale(transform, (Vec2){2, 2}); // zvÄ›tÅ¡enÃ­

A pak aplikujeÅ¡ na objekt. Kouzlo! ğŸ”®


4. ShrnutÃ­

Matice = kouzelnÃ© transformaÄnÃ­ vzorce

SDL2 je na to low-level â†’ musÃ­Å¡ si napsat vlastnÃ­ maticovÃ© funkce

NÃ¡sobenÃ­ matic = kombinovÃ¡nÃ­ transformacÃ­


///////////////////////////////////////
// Basic Initiation to Matrices, 10.7.25
///////////////////////////////////////

Oh, curious little dumpling, letâ€™s explore together how matrix math rules the world of computer graphicsâ€”even in libraries like SDL2 in C! ğŸ®âœ¨

In computer graphics, matrices are like magic wands that let you transform objects (move, rotate, scale, skew). And since SDL2 is a rather "low-level" library, we have to write some things ourselves. Donâ€™t worry, itâ€™ll be fun.

---

### 1. Basic Transformations Using Matrices  
All transformations (translation, rotation, scaling) can be expressed using matrices. We typically use 3Ã—3 matrices for 2D or 4Ã—4 for 3D, but weâ€™ll stick to 2D since SDL2 is mainly for 2D graphics.  

#### a) Translation â€“ "Little dumpling, come here!"  
If you want to move an object by (tx, ty), you use this matrix:  
| 1 0 tx |
| 0 1 ty |
| 0 0 1 |

typedef struct { float x, y; } Vec2;
typedef struct { float m[3][3]; } Mat3;

Mat3 translate(Mat3 mat, Vec2 pos) {
    mat.m[0][2] += pos.x;
    mat.m[1][2] += pos.y;
    return mat;
}
b) Rotation â€“ "Spin, little dumpling!"
If you want to rotate an object around the origin by angle Î¸, use this matrix:

| cosÎ¸  -sinÎ¸  0 |
| sinÎ¸   cosÎ¸  0 |
|  0      0    1 |



#include <math.h>

Mat3 rotate(Mat3 mat, float angle) {
    float c = cos(angle), s = sin(angle);
    Mat3 rot = {{
        {c, -s, 0},
        {s,  c, 0},
        {0,  0, 1}
    }};
    return multiply_matrices(mat, rot); // We need to write matrix multiplication
}
c) Scaling â€“ "Little dumpling, grow bigger!"
If you want to scale an object by (sx, sy), use this matrix:

text
| sx  0  0 |
| 0  sy  0 |
| 0   0  1 |


Mat3 scale(Mat3 mat, Vec2 s) {
    mat.m[0][0] *= s.x;
    mat.m[1][1] *= s.y;
    return mat;
}

2. How to Use This in SDL2?
SDL2 doesnâ€™t have built-in matrices, but we can write our own and apply them to points.

Example: Transforming a Rectangle

c
void apply_transform(SDL_Rect *rect, Mat3 transform) {
    Vec2 pos = {rect->x, rect->y};
    Vec2 new_pos = multiply_matrix_vec2(transform, pos);
    rect->x = new_pos.x;
    rect->y = new_pos.y;
    // (and similarly for width/height if we want scaling)
}


3. Why All This?
Because matrices let you combine transformations!
For example, you want to:

Move the dumpling to the right,

Rotate it by 45Â°,

Scale it 2Ã—.

Instead of doing everything step by step, just multiply the matrices:

Mat3 transform = identity_matrix(); // Start with identity matrix
transform = translate(transform, (Vec2){100, 0}); // Move  
transform = rotate(transform, M_PI/4); // Rotate (45Â° in radians)  
transform = scale(transform, (Vec2){2, 2}); // Scale  
Then apply it to your object. Magic! ğŸ”®

4. Summary
Matrices = magical transformation formulas

SDL2 is low-level â†’ You need to write your own matrix functions

Matrix multiplication = combining transformations

Result? You move, rotate, and scale objects like a boss!

text

### Key Notes:  
- Kept the playful tone ("little dumpling") for charm.  
- Used `Î¸` for theta in math notation.  
- Structured code blocks for clarity.  
- Preserved markdown formatting for headings and lists.  


