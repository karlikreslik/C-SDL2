/////////////////////////////////
// ZÃ¡kladnÃ­ zasvÄ›cenÃ­ do matic
/////////////////////////////////

Ã“, knedlÃ­Äku zvÄ›davÃ½, pojÄme spolu prozkoumat, jak maticovÃ½ poÄet ovlÃ¡dÃ¡ svÄ›t poÄÃ­taÄovÃ© grafiky, a to i v takovÃ½ch knihovnÃ¡ch, jako je tÅ™eba SDL2 v C! ğŸ®âœ¨

V poÄÃ­taÄovÃ© grafice jsou matice jako kouzelnÃ© hÅ¯lky, kterÃ© umoÅ¾ÅˆujÃ­ transformovat objekty (posouvat, otÃ¡Äet, zmenÅ¡ovat, zkreslovat). A protoÅ¾e SDL2 je spÃ­Å¡ "low-level" knihovna, musÃ­me si nÄ›kterÃ© vÄ›ci napsat sami. Neboj, bude to sranda.

1. ZÃ¡kladnÃ­ transformace pomocÃ­ matic
VÅ¡echny transformace (posun, otoÄenÃ­, zmÄ›na velikosti) se dajÃ­ vyjÃ¡dÅ™it maticemi. Obvykle pouÅ¾Ã­vÃ¡me 3Ã—3 matice pro 2D nebo 4Ã—4 pro 3D, ale my zÅ¯staneme u 2D, protoÅ¾e SDL2 je hlavnÄ› o 2D grafice.

a) Posun (Translate) â€“ "KnedlÃ­ku, pojÄ sem!"
ChceÅ¡-li posunout objekt o (tx, ty), pouÅ¾ijeÅ¡ matici:

| 1  0  tx |
| 0  1  ty |
| 0  0  1  |

typedef struct { float x, y; } Vec2;
typedef struct { float m[3][3]; } Mat3;

Mat3 translate(Mat3 mat, Vec2 pos) {
    mat.m[0][2] += pos.x;
    mat.m[1][2] += pos.y;
    return mat;
}

b) OtoÄenÃ­ (Rotate) â€“ "ToÄ se, knedlÃ­Äku!"
ChceÅ¡-li otoÄit objekt kolem poÄÃ¡tku o Ãºhel Î¸, pouÅ¾ijeÅ¡ matici:

| cosÎ¸  -sinÎ¸  0 |
| sinÎ¸   cosÎ¸  0 |
|  0      0    1 |

#include <math.h>

Mat3 rotate(Mat3 mat, float angle) {
    float c = cos(angle), s = sin(angle);
    Mat3 rot = {{
        {c, -s, 0},
        {s,  c, 0},
        {0,  0, 1}
    }};
    return multiply_matrices(mat, rot); // musÃ­me napsat nÃ¡sobenÃ­ matic
}

c) ZmÄ›na velikosti (Scale) â€“ "KnedlÃ­Äku, buÄ vÄ›tÅ¡Ã­!"
ChceÅ¡-li objekt zvÄ›tÅ¡it/zmenÅ¡it o (sx, sy), pouÅ¾ijeÅ¡ matici:

| sx  0  0 |
| 0  sy  0 |
| 0   0  1 |


Mat3 scale(Mat3 mat, Vec2 s) {
    mat.m[0][0] *= s.x;
    mat.m[1][1] *= s.y;
    return mat;
}


d) Projekce (Projection)

Projekce je jako fotka z dovolenÃ©: 3D realitu (tvoje tvÃ¡Å™ po pÃ¡tÃ©m knedlÃ­ku) splÃ¡cneÅ¡ na 2D plÃ¡tno (Instagram). V poÄÃ­taÄovÃ© grafice mÃ¡me dva hlavnÃ­ typy:

1. OrtografickÃ¡ projekce (2D/3D bez perspektivy) â€“ "KnedlÃ­k jako pravÃ­tko"
PouÅ¾Ã­vÃ¡ se v 2D hrÃ¡ch (Pixel Art, strategie) nebo v CAD.

VÅ¡echny objekty majÃ­ stejnou velikost, bez ohledu na vzdÃ¡lenost.

Matice pro ortografickou projekci v 2D (SDL2 styl):


| 2/width    0         -1 |
|    0    -2/height     1 |  
|    0        0         1 |


(PÅ™evÃ¡dÃ­ souÅ™adnice z rozsahu [0, width] a [0, height] na [-1, 1], coÅ¾ je uÅ¾iteÄnÃ© pro shadery.)

V kÃ³du (C):

Mat3 ortho(float width, float height) {
    return (Mat3) {{
        { 2.0f/width,      0,       -1 },
        {     0,     -2.0f/height,   1 },  // (minus Y, protoÅ¾e SDL2 mÃ¡ Y dolÅ¯!)
        {     0,            0,        1 }
    }};
}


2. PerspektivnÃ­ projekce (3D s iluzÃ­ hloubky) â€“ "KnedlÃ­k v prostoru!"
PouÅ¾Ã­vÃ¡ se v 3D hrÃ¡ch (Minecraft, Elden Ring).

Objekty se zmenÅ¡ujÃ­ s vzdÃ¡lenostÃ­.

Matice pro perspektivu v 3D (pro SDL2 bys musel kombinovat s 3D â†’ 2D transformacÃ­):

text
| f/aspect  0         0              0 |
| 0         f         0              0 |
| 0         0    -(far+near)/(far-near)  -2*far*near/(far-near) |
| 0         0        -1              0 |
(Kde f = cot(pole_vyhleni/2), aspect = Å¡Ã­Å™ka/vÃ½Å¡ka)

Pro SDL2 bys to musel "oÅ™ezat" na 2D, protoÅ¾e SDL2 neumÃ­ 3D pÅ™Ã­mo. Ale mÅ¯Å¾eÅ¡ simulovat perspektivu ruÄnÄ› (viz nÃ­Å¾e).

Jak pouÅ¾Ã­t projekci v SDL2?
SDL2 je 2D knihovna, ale mÅ¯Å¾eÅ¡ si projekci napodobit:

PÅ™Ã­klad: "FaleÅ¡nÃ¡ 3D perspektiva" pro knedlÃ­ky


// Transformace bodu s "hloubkou" (z)
Vec2 project_fake_3d(Vec3 point, float fov) {
    float scale = fov / (fov + point.z);  // zmenÅ¡ovÃ¡nÃ­ s vzdÃ¡lenostÃ­
    return (Vec2){ point.x * scale, point.y * scale };
}

// PouÅ¾itÃ­:
Vec3 knedlik_3d = { 100, 50, 20 };  // x, y, z
Vec2 knedlik_2d = project_fake_3d(knedlik_3d, 500.0f);
SDL_Rect rect = { knedlik_2d.x, knedlik_2d.y, 50, 50 };
SDL_RenderFillRect(renderer, &rect);  // vykreslÃ­Å¡ "3D" knedlÃ­k!


ProÄ to funguje?
Ortografie: VÅ¡echny knedlÃ­ky jsou stejnÄ› velkÃ© â†’ ideÃ¡lnÃ­ pro Pong nebo Å¡achy.

Perspektiva: BlÃ­zkÃ© knedlÃ­ky jsou vÄ›tÅ¡Ã­ â†’ vytvoÅ™Ã­Å¡ iluzi 3D (i kdyÅ¾ SDL2 nemÃ¡ 3D vykreslovÃ¡nÃ­).

ZÃ¡bavnÃ© vyuÅ¾itÃ­ v SDL2
Dungeon crawler s "faleÅ¡nÃ½mi 3D" stÄ›nami:

Vykresluj ÄÃ¡ry s mÄ›nÃ­cÃ­ se tlouÅ¡Å¥kou podle vzdÃ¡lenosti.

ParalaxnÃ­ scrolling:

Vrstvy pozadÃ­ se pohybujÃ­ rÅ¯znou rychlostÃ­ (simulace hloubky).

Pixel-artovÃ½ svÄ›t s izometrickou projekcÃ­:

PouÅ¾ij ortografickou projekci s otoÄenÃ­m o 45Â°.

------------------------

ShrnutÃ­ pro knedlÃ­ky
OrtografickÃ¡ projekce = VÅ¡echno stejnÄ› velkÃ© (2D).

PerspektivnÃ­ projekce = VzdÃ¡lenÃ© vÄ›ci menÅ¡Ã­ (3D iluze).

SDL2 je 2D â†’ musÃ­Å¡ si projekci napodobit chytÅ™e.

KnedlÃ­k v 3D? PouÅ¾ij project_fake_3d() a pÅ™edstÃ­rej, Å¾e jsi John Carmack!

TeÄ uÅ¾ vÃ­Å¡ vÅ¡echny tajnÃ© matrixovÃ© formule! ğŸ©âœ¨ UkaÅ¾ svÄ›tu, jak se transformuje knedlÃ­k jako profÃ­k!

(P.S.: Pokud chceÅ¡ skuteÄnÃ© 3D v C, koukni na OpenGL nebo Vulkan )


----------------------


2. Jak to pouÅ¾Ã­t v SDL2?
SDL2 sice nemÃ¡ vestavÄ›nÃ© matice, ale mÅ¯Å¾eme si je napsat a aplikovat na body.

PÅ™Ã­klad: Transformace obdÃ©lnÃ­ku

void apply_transform(SDL_Rect *rect, Mat3 transform) {
    Vec2 pos = {rect->x, rect->y};
    Vec2 new_pos = multiply_matrix_vec2(transform, pos);
    rect->x = new_pos.x;
    rect->y = new_pos.y;
    // (a podobnÄ› pro Å¡Ã­Å™ku/vÃ½Å¡ku, pokud chceme Å¡kÃ¡lovÃ¡nÃ­)
}

------------------------

3. ProÄ to vÅ¡echno?
ProtoÅ¾e matice umoÅ¾ÅˆujÃ­ kombinovat transformace
NapÅ™. chceÅ¡:

Posunout knedlÃ­k doprava,

OtoÄit ho o 45Â°,

ZvÄ›tÅ¡it ho 2Ã—.

MÃ­sto dÄ›lenÃ­ vÅ¡eho na jednotlivÃ© kroky prostÄ› vynÃ¡sobÃ­Å¡ matice:

Mat3 transform = identity_matrix(); // zaÄneme jednotkovou maticÃ­
transform = translate(transform, (Vec2){100, 0}); // posun
transform = rotate(transform, M_PI/4); // otoÄenÃ­ (45Â° v radiÃ¡nech)
transform = scale(transform, (Vec2){2, 2}); // zvÄ›tÅ¡enÃ­

A pak aplikujeÅ¡ na objekt. Kouzlo! ğŸ”®

-----------------------------
4. ShrnutÃ­

Matice = kouzelnÃ© transformaÄnÃ­ vzorce

SDL2 je na to low-level â†’ musÃ­Å¡ si napsat vlastnÃ­ maticovÃ© funkce

NÃ¡sobenÃ­ matic = kombinovÃ¡nÃ­ transformacÃ­



